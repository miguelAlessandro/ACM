/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author Miguel Mini
 * @tag dp_on_trees, lca_optimization
 * @idea
 *      - we can make a simple dp(node, steps, is_complete_my_travel?)
 *      with update:
 * 
 *      dp_new(x, i + j, 0) = max_{u is son of x} 
 *                                  (dp_old(x, i, 0) + dp(u, j - 2, 1), dp_old(x, i, 1) + dp(u, j - 1, 0)) 
 *      dp_new(x, i + j, 1) = max_{u is son of x}
 *                                  dp_old(x, i, 1) + dp(u, j - 2, 1)
 *                                  
 * @complexity O(nm) with combinatorial observations.
 */

#include <bits/stdc++.h>
#define sz(x) (int)x.size()
#define trav(v, x) for (auto v : x)
#define re(x, y, z) for (int x=y; x<z; ++x)
#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
#define set_to(x, v) fill(all(x), v)
#define eb emplace_back
#define lso(x) ((x)&-(x))
using namespace std;
using ll = long long;
using ii = pair<int, int>;
using vi = vector<int>;
const int mod = 1e9 + 7;
const int maxn = 505;
int A[maxn];
int n, m;
vi g[maxn];
int dp[maxn][maxn][2];
int sz[maxn];

int dfs(int x, int p) {
    sz[x] = 1;
    dp[x][0][0] = dp[x][0][1] = 0;
    dp[x][1][0] = dp[x][1][1] = A[x];
    trav(v, g[x]) {
        if (v == p) continue;
        dfs(v, x);
        sz[x] += sz[v];
        for (int i = min(m, 3 * sz[x] - 2); i >= 1; --i) {
            for (int j = min(i, 3 * sz[v]); j >= max(1, i - 3 * (sz[x] - sz[v])); --j) {
                dp[x][i][0] = max(dp[x][i][0], dp[x][i - j][1] + dp[v][j - 1][0]);
                if (j >= 2) {
                    dp[x][i][0] = max(dp[x][i][0], dp[x][i - j][0] + dp[v][j - 2][1]);
                    dp[x][i][1] = max(dp[x][i][1], dp[x][i - j][1] + dp[v][j - 2][1]);
                }
            }
        }
    }
}

class COC_18_dostavljac {
public:
    void solveOne(istream& in, ostream& out) {
        in >> n >> m;
        m = min(m, 3*n - 2);
        re(i, 1, n + 1) {
            in >> A[i];
        }
        memset(dp, 0, sizeof dp);
        re(i, 1, n+1) g[i].clear();
        re(i, 1, n) {
            int a, b;
            in >> a >> b;
            g[a].eb(b);
            g[b].eb(a);
        }
        dfs(1, 0);
        int ans = 0;
        for (int i = 0; i <= m; ++i) {
            ans = max(ans, dp[1][i][0]);
        }
        out << ans << endl;
    }

    void solve(istream& in, ostream& out) {
        int testNumber = 1;
        //in >> testNumber;
        re(tc, 1, testNumber+1) {
            //out << "Case #" << tc << ": ";
            solveOne(in, out);
        }
    }
};


int main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
	COC_18_dostavljac solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	solver.solve(in, out);
	return 0;
}
