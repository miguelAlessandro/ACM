/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author Miguel Mini
 * @tag dp, math
 * @idea
 *      - we can have a dp[x] indicating the first value
 *      a[0] * k + x that can be formed, this can be done
 *      with a dp subset sum, but modular.
 *
 *      - at first glance you should consider the possible
 *      cycles, making an algorithm O (n a[0]^2), but we can
 *      realize that it is never convenient for us to repeat
 *      a state, with wich we have a O(n a[0]) complexity.
 *
 *      note: A spfa solution passed in good time
 *
 *      - we can cancel having to mark the states if we notice
 *      that if we start in a j < gcd(a[0], a[i]) we are going
 *      to complete one of the cycles, therefore achieving a
 *      better constant for our complexity.
 *
 *          t * a[i] / g = 0 (mod a[0] / g)
 *      
 *      t has O(a[0] / g) solutions.
 */

#include <bits/stdc++.h>
#define sz(x) (int)x.size()
#define trav(v, x) for (auto v : x)
#define re(x, y, z) for (int x=y; x<z; ++x)
#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
#define set_to(x, v) fill(all(x), v)
#define eb emplace_back
#define lso(x) ((x)&-(x))
using namespace std;
using ll = long long;
using ii = pair<int, int>;
using vi = vector<int>;
const int mod = 1e9 + 7;
const int maxn = 5002;
const int maxa = 50002;
int a[maxn], b[maxn];
int dp[maxa];
bool vis[maxa];

int add(int x, int y) {
    return x + y < a[0] ? x + y : x + y - a[0];
}

class sums {
public:

    void solveOne(istream& in, ostream& out) {
        int n;
        in >> n;
        re(i, 0, n) {
            in >> a[i];
        }
        re(i, 0, n) {
            b[i] = a[i] % a[0];
        }
        re(i, 1, a[0]) {
            dp[i] = 2e9;
        }
        dp[0] = 0;
        re(i, 1, n) {
            if (b[i] == 0) continue;
            int m = __gcd(a[0], a[i]);
            re(j, 0, m) {
                int prv = j, nxt = add(j, b[i]);
                while (nxt != j) {
                    vis[prv] = 1;
                    dp[nxt] = min(dp[nxt], dp[prv] + a[i]);
                    prv = nxt;
                    nxt = add(nxt, b[i]);
                }
            }
        }
        int k;
        in >> k;
        re(i, 0, k) {
            int x;
            in >> x;
            out << (dp[x % a[0]] <= x ? "TAK" : "NIE") << endl;
        }
    }

    void solve(istream& in, ostream& out) {
        int testNumber = 1;
        //in >> testNumber;
        re(tc, 1, testNumber+1) {
            //out << "Case #" << tc << ": ";
            solveOne(in, out);
        }
    }
};


int main() {
  ios_base::sync_with_stdio(0);
  cin.tie(0); cout.tie(0);
	sums solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	solver.solve(in, out);
	return 0;
}
